---
title: "Visualising Two Variables"
subtitle: "Data Visualisation and Analytics"
author: "Anastasios Panagiotelis"
date: "Lecture 4"
output:
  xaringan::moon_reader:
    chakra: libs/remark-latest.min.js
    lib_dir: libs
    css: [default,"css/mtheme.css","css/mod.css"]
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

class: inverse, center, middle

# Relationships

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
require(magrittr)
require(tidyverse)
require(plotly)
require(widgetframe)
require(animation)
require(DT)
require(PoEdata)
require(kableExtra)
require(gridExtra)
require(ggmosaic)
```

---

# Visualising two variables

- Two Metric variables
  - Scatter plot
- One non-metric one metric
  - Boxplots
  - Violin plots
- Two non-metric
  - Mosaic plot
  
---

# What to look for

- Outliers
- Dependence or correlation
- Remember that correlation does not imply causation!
- Non linear relationships.

---
class: inverse, middle, center

# Two metric variables

---

# Scatter plot

- For two metric variables use a scatter plot
  - One variable is represented by the `x` aesthetic
  - The other is represented by the `y` aesthetic
  - The geometry we use is `geom_point`.
- We will continue to use the `diamonds` dataset
  
---

# Scatterplot

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+geom_point()
  
```

---

# Changing color

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_point(color='orange')
  
```

---

#Overplotting

- When using big datasets, sometimes the points cover one another or are too close.
- This is sometimes called **overplotting**.
- Some solutions:
  - Try smaller points (size)
  - Try more transparent points (alpha)
  - Try a different geom
  
---

# Changing size

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_point(size=0.1)
  
```

---

# Changing alpha

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_point(alpha=0.2)
  
```
---

# Changing geom

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_bin2d()
  
```

---

# Changing geom

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_density2d()
  
```

---

# Scale

- For variables that are heavily skewed it can be better to look at a log scale.
- For a regular scale you *add* as you move up the scale.
- For a log scale you *multiply* as you move up the scale.
- The log scale has the effect of putting more distance between smaller values and compressing higher values.

---


# Regular scale

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_point()
  
```

---


# Log scale


```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=carat,y=price))+
  geom_point()+scale_x_log10()+scale_y_log10()
  
```

---
class:inverse, middle, center

# An aside on log scales
---

# Zipf's Law

- In text mining, a well known empirical result is that the occurence of words in a document often follows Zipf's law

$$\mbox{Prob}(r)=\frac{r^{-s}}{K}$$

- Here $r$ is the rank of the word (1 is the most frequent, $N$ the least frequent).
- $K=\sum\limits^{N}_{x=1}x^{-s}$ is constant with respect to $r$.

---

# Three documents

- We will look at three documents:
  - The Australian Constitution
  - The script of Avengers Endgame
  - The homepage of online retailer Tao Bao.

---

# Australian Constitution

```{r, message=FALSE}
AusConsFreq<-read_csv('data/AusConstitution.csv')
AusConsFreq%>%
  filter(Rank<51)%>%
  ggplot(aes(x=reorder(Word,Rank),y=Freq))+
  geom_point()+
  labs(x='Word')+
  theme(axis.text.x = element_text(angle=90))
```

---

#Australian Constitution

```{r, message=FALSE}
AusConsFreq%>%
  ggplot(aes(x=Rank,y=Freq))+
  geom_point()
```

---

# Zipf Law

- Zipf's law predicts that

$$\mbox{Pr}(r)\approx r^{-s}/K$$

- Taking logs on both sides

$$log(f(r))\approx -slog(r)-log(K)$$

- Look at the plot on the log scale.

---

#Australian Constitution

```{r, message=FALSE}
AusConsFreq%>%
  ggplot(aes(x=Rank,y=Freq))+
  geom_point()+
  scale_x_log10()+
  scale_y_log10()
```

---
# Avengers Endgame

```{r, message=FALSE}
Avengers<-read_csv('data/Avengers.csv')
Avengers%>%
  filter(Rank<51)%>%
  ggplot(aes(x=reorder(Word,Rank),y=Freq))+
  geom_point()+
  labs(x='Word')+
  theme(axis.text.x = element_text(angle=90))
```

---

#Avengers Endgame

```{r, message=FALSE}
Avengers%>%
  ggplot(aes(x=Rank,y=Freq))+
  geom_point()
```

---

#Avengers Endgame

```{r, message=FALSE}
Avengers%>%
  ggplot(aes(x=Rank,y=Freq,label=Word))+
  geom_text(size=3)+
  scale_x_log10()+
  scale_y_log10()->g
ggplotly(g)%>%
  frameWidget(width = '100%',height = '100%')
```
---
# Tao Bao

```{r, message=FALSE}
TaoBao<-read_csv('data/TaoBao.csv')
TaoBao%>%
  filter(Rank<51)%>%
  ggplot(aes(x=reorder(Character,Rank),y=Freq))+
  geom_point()+
  labs(x='Character')+
  theme(axis.text.x = element_text(angle=90))
```

---

#Tao Bao

```{r, message=FALSE}
TaoBao%>%
  ggplot(aes(x=Rank,y=Freq))+
  geom_point()
```

---

#Tao Bao

```{r, message=FALSE}
TaoBao%>%
  ggplot(aes(x=Rank,y=Freq,label=Character))+
  geom_text(size=3)+
  scale_x_log10()+
  scale_y_log10()->g
ggplotly(g)%>%
  frameWidget(width = '100%',height = '100%')
```
---

# Other applications

- A similar observation is also made for the size of companies.
- Gibrat's Law claims that the growth rate of a company is independent of its size.
- This implies that the distribution of company size will be similar to the distribution of word frequency.
- Gibrat's law has also been applied to city populations.

---
class: inverse, middle center

# Time series plots

---
# Time series plots

- When the x variable is time, it often makes more sense to join dots with a line.
- This way we can see 
  - Trend 
  - Seasonality 
  - Outliers
  - Structural break

---

# Economics dataset

- We will use the economics dataset (comes with ggplot2)

```{r, echo=TRUE}
str(economics)
```
- Notice date is its own type of variable

---

# Unemployed persons

```{r, echo=TRUE,fig.height=5}
ggplot(economics, aes(x=date, y=unemploy))+
  geom_line()

```

---

#Terminology

- By *trend* we mean data that either tends to move upwards or downwards over time.
- By *seasonality* we tend to refer to a repeating pattern.
- By *period* we mean the number of observations for the seasonal pattern to repeat itself.
- By *frequency* we refer to how regularly an observation is measured.

---

# Your Turn

- Three datasets
  - UK driving deaths (monthly)
  - UK Gas Consumption (quarterly)
  - Returns on DAX (daily)
- For each datasets
  - Is there trend?
  - Is there seasonality?
  - If so what is the period of seasonality?
  - Are there outliers or structural breaks?
---

# UK Driving Deaths

```{r,message=FALSE}
tibble(UKDriverDeaths)%>%
  add_column(Time=seq.Date(as.Date('1969/1/1'),
                           as.Date('1984/12/1'),
                           by='month'))%>%
  ggplot(aes(x=Time,y=UKDriverDeaths))+geom_line()->g
ggplotly(g)%>%
  frameWidget(width = '100%',height = '100%')

```

---

#UK Gas Consumption

```{r,message=FALSE}

dd<-seq.Date(as.Date('1960/3/1'),
             as.Date('1986/11/1'),
             length.out = 108)
tibble(UKgas)%>%
  add_column(Time=dd)%>%
  ggplot(aes(x=Time,y=UKgas))+geom_line()->g
ggplotly(g)%>%
  frameWidget(width = '100%',height = '100%')

```

---

# DAX

```{r, message=FALSE}
EuStockMarkets%>%
  log%>%
  diff%>%
  as_tibble()%>%
  add_column(Time=time(EuStockMarkets)[2:1860])%>%
  ggplot(aes(x=Time,y=DAX))+geom_line()->g
ggplotly(g)%>%
  frameWidget(width = '100%',height = '100%')
```

---

# More on time series

- Visualising time series is very common in business.
- For this reason we revisit some specific issues around time series plots later in the semester.

---
class: inverse, middle, center

# One metric and one non-metric variable

---

# Side by side plots

- When one variable is metric and the other non-metric we can easily put plots next to one another side by side.
- Simply map the non-metric variable to the x aesthetic and the metric variable to the y aesthetic.

---

# Boxplots

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=cut,y=price))+
  geom_boxplot()
  
```

---

# Change axes (wrong way)

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=price,y=cut))+
  geom_boxplot()
  
```

---

# Change axes (right way)

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=cut,y=price))+
  geom_boxplot()+coord_flip()
  
```

---

# With notches

- Recall that the notches provide a confidence interval around the median.
--

- These are particularly useful when comparing boxplots to one another.
--

- In general, if the confidence intervals overlap then the medians are not signficantly different.
--

- This is NOT a formal test, but still gives a useful indication.

---

# Boxplots (no overlap)

```{r, echo=TRUE,fig.height=5}
ggplot(data = mpg,
       mapping = aes(x=drv,y=hwy))+
  geom_boxplot(notch=T)
  
```

---
# Boxplots (some overlap)

```{r, echo=FALSE,fig.height=5}
filter(mpg,!(class%in%c('2seater','subcompact')))%>%
  ggplot(mapping = aes(x=class,y=hwy))+
  geom_boxplot(notch=T)
  
```

---
# Violin plot

- A violin plot is a newer visualisation.
- A kernel density is mirrored then arranged vertically.
- Specify the same way but use *geom_violin*
---

# Violin plot

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=cut,y=price))+
  geom_violin()
  
```

---

# Violin plot

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds,
       mapping = aes(x=cut,y=price))+
  geom_violin()+coord_flip()
  
```

---

# Jittering

- A scatter plot can be used for non-metric data but can easily suffer from overplotting (one point on another). 

```{r, fig.height=5}
ggplot(data = mpg,
       mapping = aes(x=cyl,y=cty))+
  geom_point()

```

---

#Jittering

- Add random noise by jittering

```{r, echo=TRUE, fig.height=4}
ggplot(data = mpg,
       mapping = aes(x=cyl,y=cty))+
  geom_point(position = 'jitter')

```

---
class: inverse, center middle

# Two non-metric variables

---

# Mosaic plot

- The mosaic plot is another fairly new visualisation.
- To plot them we use a new package `ggmosaic`
- The `geom_mosaic` function integrates nicely with ggplot.
- Think of it as a cross tab but where the size of the cell indicates the frequency.
---

#Diamonds cross tab

```{r}
table(diamonds$color,diamonds$clarity)%>%
  kable%>%
  kable_styling()
```
---

# Mosiac plot

```{r, echo=TRUE,fig.height=5}
ggplot(data = diamonds)+
  geom_mosaic(aes(x=product(color,clarity)))
  
```

---

# Mosaic plot

- The specification of aes is a little unusual since this is not from the `ggplot2` package.
- To interpret the mosaic plot, the more that the horizontal gaps line up, the closer the data are to independence.

---

# Titanic

```{r}
knitr::include_graphics('img/titanic.jpeg')
knitr::include_graphics('img/jackrose.jpeg')
```

---

# Titanic (real data)

```{r,echo=FALSE}
data(Titanic)
titanic <- as.data.frame(Titanic)
titanic$Survived <- factor(titanic$Survived, levels=c( "No","Yes"))

ggplot(data=titanic) +
  geom_mosaic(aes(weight=Freq,x=product(Class,Survived)))
```

---

# Titanic (if independent)


```{r,echo=FALSE}
titind<-tibble(
  Class=c('1st','2nd','3rd','Crew','1st','2nd','3rd','Crew'),
  Survived=c('No','No','No','No','Yes','Yes','Yes','Yes'),
  Freq=c(220,193,478,599,105,92,228,286))

ggplot(data=titind) +
  geom_mosaic(aes(weight=Freq,x=product(Class,Survived)))
```

---

# More than two variables

- Generally interested in more than two variables.
- Next lecture we will learn to use
  - Color
  - Size
  - Labels
  - Facets